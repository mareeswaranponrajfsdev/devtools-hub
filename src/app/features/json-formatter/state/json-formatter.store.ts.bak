import { Injectable, signal, computed } from '@angular/core';
import { JsonEngine } from '../services/json-engine';
import { JsonAutoFix } from '../services/json-auto-fix';
import { JsonConverterService, ConversionFormat } from '../services/json-converter.service';
import { FormatterOptions, DEFAULT_FORMATTER_OPTIONS } from '../models/formatter-options.model';

interface HistoryEntry {
  value: string;
  timestamp: number;
}

const STORAGE_KEY = 'json-formatter-options';

@Injectable()
export class JsonFormatterStore {

  constructor(
    private engine: JsonEngine,
    private autoFix: JsonAutoFix,
    private converter: JsonConverterService
  ) {
    this.loadOptionsFromStorage();
  }


  /* ================= STATE ================= */

  // Input JSON
  input = signal<string>('');

  // Output JSON
  output = signal<string>('');

  // Error message
  error = signal<string | null>(null);

  // Live validation toggle
  liveMode = signal<boolean>(false);

  // Tree view toggle
  treeView = signal<boolean>(false);

  // Current conversion format
  currentConversion = signal<ConversionFormat | null>(null);

  // Formatter options
  formatterOptions = signal<FormatterOptions>(DEFAULT_FORMATTER_OPTIONS);

  // Undo/Redo history
  private history: HistoryEntry[] = [];
  private historyIndex = -1;
  private maxHistorySize = 50;

  canUndo = signal<boolean>(false);
  canRedo = signal<boolean>(false);


  /* ================= COMPUTED ================= */

  // Character count
  charCount = computed(() => this.input().length);

  // Line count
  lineCount = computed(() => {
    if (!this.input()) return 0;
    return this.input().split('\n').length;
  });

  // File size (KB)
  fileSize = computed(() => {
    return (new Blob([this.input()]).size / 1024).toFixed(2);
  });


  /* ================= ACTIONS ================= */

  setInput(value: string, addToHistory = true) {

    this.input.set(value);

    if (addToHistory) {
      this.addToHistory(value);
    }

    if (this.liveMode()) {
      this.validate();
    }
  }


  toggleLive() {
    this.liveMode.update(v => !v);
  }


  toggleTreeView() {
    this.treeView.update(v => !v);
  }


  // -------- Formatter Options --------
  updateOptions(options: FormatterOptions) {
    this.formatterOptions.set(options);
    this.saveOptionsToStorage(options);
  }

  private saveOptionsToStorage(options: FormatterOptions) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(options));
    } catch (e) {
      console.error('Failed to save formatter options:', e);
    }
  }

  private loadOptionsFromStorage() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const options = JSON.parse(stored);
        this.formatterOptions.set({ ...DEFAULT_FORMATTER_OPTIONS, ...options });
      }
    } catch (e) {
      console.error('Failed to load formatter options:', e);
    }
  }


  // -------- Format --------
  format() {

    // Reset conversion when formatting
    this.currentConversion.set(null);

    try {

      const result = this.engine.format(this.input(), this.formatterOptions());

      this.output.set(result);
      this.error.set(null);

    } catch (err: any) {

      this.handleError(err);

    }

  }


  // -------- Minify --------
  minify() {

    // Reset conversion when minifying
    this.currentConversion.set(null);

    try {

      const result = this.engine.minify(this.input());

      this.output.set(result);
      this.error.set(null);

    } catch (err: any) {

      this.handleError(err);

    }

  }


  // -------- Auto Fix --------
  autoFixJson(): void {

    const input = this.input().trim();

    if (!input) {
      this.error.set('Please enter JSON first');
      return;
    }

    try {

      // Apply auto-fix
      const fixed = this.autoFix.fix(input);

      // Validate it works
      JSON.parse(fixed);

      // Update input with fixed version
      this.setInput(fixed);

      // Format the output
      this.format();

      this.error.set('JSON auto-fixed successfully!');

      this.autoClearMessage();

    } catch (err: any) {

      this.error.set('Could not auto-fix JSON: ' + err.message);

    }

  }


  // -------- Validate --------
  validate(): void {

    const input = this.input().trim();

    if (!input) {
      this.error.set('Please enter JSON first');
      return;
    }

    try {

      JSON.parse(input);

      this.error.set('JSON is Valid');

      this.autoClearMessage();

    } catch (err: any) {

      this.error.set('Invalid JSON: ' + err.message);

    }

  }

  private autoClearMessage(): void {

    setTimeout(() => {
      this.error.set(null);
    }, 2000);

  }


  // -------- Clear --------
  clear() {

    this.setInput('');
    this.output.set('');
    this.error.set(null);
    this.currentConversion.set(null);

  }


  // -------- Copy Output --------
  copy() {

    if (!this.output()) return;

    navigator.clipboard.writeText(this.output());

  }


  /* ================= UNDO/REDO ================= */

  private addToHistory(value: string): void {

    // Don't add if value hasn't changed
    if (this.history[this.historyIndex]?.value === value) {
      return;
    }

    // Remove any forward history
    this.history = this.history.slice(0, this.historyIndex + 1);

    // Add new entry
    this.history.push({
      value,
      timestamp: Date.now()
    });

    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }

    this.updateUndoRedoState();

  }

  undo(): void {

    if (this.historyIndex > 0) {
      this.historyIndex--;
      const entry = this.history[this.historyIndex];
      this.input.set(entry.value);
      this.updateUndoRedoState();
    }

  }

  redo(): void {

    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      const entry = this.history[this.historyIndex];
      this.input.set(entry.value);
      this.updateUndoRedoState();
    }

  }

  private updateUndoRedoState(): void {
    this.canUndo.set(this.historyIndex > 0);
    this.canRedo.set(this.historyIndex < this.history.length - 1);
  }


  /* ================= CONVERSION ================= */

  convert(format: ConversionFormat | null): void {

    if (format === null) {
      // Reset to JSON
      this.currentConversion.set(null);
      this.format();
      return;
    }

    const output = this.output();

    if (!output) {
      this.error.set('Please format JSON first');
      return;
    }

    try {

      let converted = '';

      switch (format) {
        case 'xml':
          converted = this.converter.toXml(output);
          break;
        case 'csv':
          converted = this.converter.toCsv(output);
          break;
        case 'yaml':
          converted = this.converter.toYaml(output);
          break;
      }

      this.output.set(converted);
      this.currentConversion.set(format);
      this.error.set(null);

    } catch (err: any) {

      this.error.set(`Conversion failed: ${err.message}`);

    }

  }


  /* ================= HELPERS ================= */

  private handleError(err: any) {

    const msg = err?.message || 'Invalid JSON';

    this.error.set(msg);

    this.output.set('');

  }

}
